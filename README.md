## 1.目的
駅と駅を結ぶ線路(距離付き)から**同じ駅を二度と通らない最長経路**を求め、その駅番号を上から順に出力します。
## 2. ファイル構成
`longest_ticket.py` メインスクリプト(Python3, 標準ライブラリのみ)
## 3. 使い方
bash:
```
python3 longest_ticket.py < input.txt
```
- **入力**
  - 行ごとに「`from, to, distance`」という書式で駅間を記載してください。
  - カンマの前後にスペースがあっても構いません。
  - 例) `2, 9,  31.31`
- **出力**
  - 最長経路を構成する駅番号を１行ずつ標準出力に書き出します。
## 4.アルゴリズム概要
  
|**駅数**|**手法**|**計算量**|
|:---|:---|:---|
|20以下|**ビットマスクDP**|時間 *O(n<sup>2</sup>・2<sup>n</sup>)*, メモリ *O(n・2<sup>n</sup>)* |
|21以上|**DFS + メモ化付き枝刈り**|最悪指数時間※|

※数十駅クラスなら数秒以内で完了します。
### 1.情報取り込み
- 行を読み取り、駅IDを整数に変換。
- 線路は「行き」「帰り」両方向に走れるとみなし、隣接リストに両方登録します。
### 2.経路探索
- 駅数が20以下: 全ビット列を列挙するDP。
- 21以上: 深さ優先探索。すでにより長い距離で訪れた状態は再度調べない。
### 3.経路復元
- 各状態の親状態を保存しておき、最長状態から逆順にたどって駅リストを作成します。

## 5.コードに関する詳細
行数|処理|説明
:---|:---|:---
24-34|入力解析|正規表現でカンマ区切りを安全に分割。空行は無視。
38-43|グラフ生成|`adj[a].append((b,w))`と`adj[b].append((a,w))`で双方向登録。
52-78|ビットマスクDP部|`dp[mask][u]`に長さを保持。親も`parent`に記録。
82-104|DFS部分|`seen[(mask, u)]`に最長距離をメモして枝刈り。
107-114|経路復元|`parent`をたどって駅番号を`print()`。

## 6.動作確認
入力:
```
2, 3, 3.81
2, 4, 5.61
3, 5, 8.31
5, 6, 1.31
2, 8, 15.12
2, 9, 31.31
3, 8, 27.11
7, 8, 1.11
```
出力:
```
6
5
3
8
2
9
```

## 7.実行環境
- python3.8以上
- 外部ライブラリ不要（標準ライブラリのみ）

## 8.制限事項
- 駅数が多くかつ蜜なグラフではDFS版が時間的に厳しい場合があります。テスト使用(数十駅程度)では問題ありません。
